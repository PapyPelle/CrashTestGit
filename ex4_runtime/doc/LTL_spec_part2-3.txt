open o
close c
isApproved a
withdraw  w

([mX /call/method] ((mX) = ({name})))

-> Les opérations isApproved et withdraw ne peuvent être effectuées que si un compte est ouvert.

!(a | w) W o  // isApproved et withdraw cannot be called until open is called
G (c -> (!a & !w) W o) // calling close will reset above condition



-> On ne peut ouvrir plus d'un compte simultanément.


G (o -> (!o W c)) // whenever we call o, we cannot have another o unitl we have a c



-> Un retrait de plus de 1 000 $ ne peut être effectué que si l'appel à isApproved a retourné true.

-------------------------------------------------
PROTOTYPES

void Bank.open(int act);
void Bank.close(int act);
void Bank.withdraw(int act, int amt);
boolean Bank.isApproved(int act, int amt);

SPEC LTL-FO+

(([m11 /call/method] (!((m11) = ({withdraw})) | ((m11) = ({isApproved}))))
	W ([m12 /call/method] ((m12) = ({open}))))
&
(G ( ([m21 /call/method] ((m21) = ({close}))) ->
	(([m22 /call/method] (!((m22) = ({withdraw})) | ((m22) = ({isApproved})))) W ([m23 /call/method] ((m23) = ({open}))))))
&
(G (([m31 /call/method] ((m31) = ({open}))) -> (
	(!([m32 /call/method] ((m32) = ({open}))))
	W
	([m33 /call/method] ((m33) = ({close}))))))
&
((!([m41 /call/method] ([p41 /params/amt] (((m41) = ({withdraw})) & ((p41) > ({1000})))))) W
	([m42 /call/method] ([p42 /params/amt] (((m42) = ({isApproved})) & ((p41) = (p42))))))



@FALSE {
  System.out.println("The error was successfully caught !");
}
---------------------------------------------------------------------------------
w_light e_light
at_w at_e
on_bridge

-> Les deux feux ne sont jamais verts en même temps

G (w_light & e_light)

-> Chaque feu ne reste vert que pour 3 états successifs
i.e. 3 états verts d'un feu implique un passage au rouge au 4e

G ( (w_light & (X (w_light & (X w_light))) -> X(!w_light) )

-> Un feu ne devient vert que si une voiture attend
-> Un feu ne peut passer au vert si des voitures sont sur le pont
i.e. si un feu rouge passe au vert cela implique qu'une voiture attend et qu'il n'y a personne sur le pont

G ( (!w_light & (X w_light)) -> (at_w && !on_bridge) )

-> Si un feu est vert, une voiture à l'intersection correspondante se retrouve sur le pont dans l'état suivant

G ( (w_light & at_w) -> X (on_bridge) )
